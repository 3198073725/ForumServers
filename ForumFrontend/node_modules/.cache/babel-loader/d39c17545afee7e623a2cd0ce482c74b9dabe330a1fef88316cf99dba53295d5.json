{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/objectSpread2.js\")[\"default\"];\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.sort.js\");\nrequire(\"core-js/modules/es.object.define-property.js\");\nrequire(\"core-js/modules/es.object.keys.js\");\nrequire(\"core-js/modules/web.timers.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vue = require('vue');\nvar core = require('@vueuse/core');\nvar anchor = require('./anchor.js');\nvar constants = require('./constants.js');\nvar pluginVue_exportHelper = require('../../../_virtual/plugin-vue_export-helper.js');\nvar element = require('../../../utils/dom/element.js');\nvar throttleByRaf = require('../../../utils/throttleByRaf.js');\nvar types = require('../../../utils/types.js');\nvar scroll = require('../../../utils/dom/scroll.js');\nvar position = require('../../../utils/dom/position.js');\nvar index = require('../../../hooks/use-namespace/index.js');\nvar event = require('../../../constants/event.js');\nvar __default__ = vue.defineComponent({\n  name: \"ElAnchor\"\n});\nvar _sfc_main = /* @__PURE__ */vue.defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: anchor.anchorProps,\n  emits: anchor.anchorEmits,\n  setup: function setup(__props, _ref) {\n    var expose = _ref.expose,\n      emit = _ref.emit;\n    var props = __props;\n    var currentAnchor = vue.ref(\"\");\n    var anchorRef = vue.ref(null);\n    var markerRef = vue.ref(null);\n    var containerEl = vue.ref();\n    var links = {};\n    var isScrolling = false;\n    var currentScrollTop = 0;\n    var ns = index.useNamespace(\"anchor\");\n    var cls = vue.computed(function () {\n      return [ns.b(), props.type === \"underline\" ? ns.m(\"underline\") : \"\", ns.m(props.direction)];\n    });\n    var addLink = function addLink(state) {\n      links[state.href] = state.el;\n    };\n    var removeLink = function removeLink(href) {\n      delete links[href];\n    };\n    var setCurrentAnchor = function setCurrentAnchor(href) {\n      var activeHref = currentAnchor.value;\n      if (activeHref !== href) {\n        currentAnchor.value = href;\n        emit(event.CHANGE_EVENT, href);\n      }\n    };\n    var clearAnimate = null;\n    var scrollToAnchor = function scrollToAnchor(href) {\n      if (!containerEl.value) return;\n      var target = element.getElement(href);\n      if (!target) return;\n      if (clearAnimate) clearAnimate();\n      isScrolling = true;\n      var scrollEle = scroll.getScrollElement(target, containerEl.value);\n      var distance = position.getOffsetTopDistance(target, scrollEle);\n      var max = scrollEle.scrollHeight - scrollEle.clientHeight;\n      var to = Math.min(distance - props.offset, max);\n      clearAnimate = scroll.animateScrollTo(containerEl.value, currentScrollTop, to, props.duration, function () {\n        setTimeout(function () {\n          isScrolling = false;\n        }, 20);\n      });\n    };\n    var scrollTo = function scrollTo(href) {\n      if (href) {\n        setCurrentAnchor(href);\n        scrollToAnchor(href);\n      }\n    };\n    var handleClick = function handleClick(e, href) {\n      emit(\"click\", e, href);\n      scrollTo(href);\n    };\n    var handleScroll = throttleByRaf.throttleByRaf(function () {\n      if (containerEl.value) {\n        currentScrollTop = scroll.getScrollTop(containerEl.value);\n      }\n      var currentHref = getCurrentHref();\n      if (isScrolling || types.isUndefined(currentHref)) return;\n      setCurrentAnchor(currentHref);\n    });\n    var getCurrentHref = function getCurrentHref() {\n      if (!containerEl.value) return;\n      var scrollTop = scroll.getScrollTop(containerEl.value);\n      var anchorTopList = [];\n      for (var _i = 0, _Object$keys = Object.keys(links); _i < _Object$keys.length; _i++) {\n        var href = _Object$keys[_i];\n        var target = element.getElement(href);\n        if (!target) continue;\n        var scrollEle = scroll.getScrollElement(target, containerEl.value);\n        var distance = position.getOffsetTopDistance(target, scrollEle);\n        anchorTopList.push({\n          top: distance - props.offset - props.bound,\n          href: href\n        });\n      }\n      anchorTopList.sort(function (prev, next) {\n        return prev.top - next.top;\n      });\n      for (var i = 0; i < anchorTopList.length; i++) {\n        var item = anchorTopList[i];\n        var next = anchorTopList[i + 1];\n        if (i === 0 && scrollTop === 0) {\n          return props.selectScrollTop ? item.href : \"\";\n        }\n        if (item.top <= scrollTop && (!next || next.top > scrollTop)) {\n          return item.href;\n        }\n      }\n    };\n    var getContainer = function getContainer() {\n      var el = element.getElement(props.container);\n      if (!el || types.isWindow(el)) {\n        containerEl.value = window;\n      } else {\n        containerEl.value = el;\n      }\n    };\n    core.useEventListener(containerEl, \"scroll\", handleScroll);\n    var markerStyle = vue.computed(function () {\n      if (!anchorRef.value || !markerRef.value || !currentAnchor.value) return {};\n      var currentLinkEl = links[currentAnchor.value];\n      if (!currentLinkEl) return {};\n      var anchorRect = anchorRef.value.getBoundingClientRect();\n      var markerRect = markerRef.value.getBoundingClientRect();\n      var linkRect = currentLinkEl.getBoundingClientRect();\n      if (props.direction === \"horizontal\") {\n        var left = linkRect.left - anchorRect.left;\n        return {\n          left: \"\".concat(left, \"px\"),\n          width: \"\".concat(linkRect.width, \"px\"),\n          opacity: 1\n        };\n      } else {\n        var top = linkRect.top - anchorRect.top + (linkRect.height - markerRect.height) / 2;\n        return {\n          top: \"\".concat(top, \"px\"),\n          opacity: 1\n        };\n      }\n    });\n    vue.onMounted(function () {\n      getContainer();\n      var hash = decodeURIComponent(window.location.hash);\n      var target = element.getElement(hash);\n      if (target) {\n        scrollTo(hash);\n      } else {\n        handleScroll();\n      }\n    });\n    vue.watch(function () {\n      return props.container;\n    }, function () {\n      getContainer();\n    });\n    vue.provide(constants.anchorKey, {\n      ns: ns,\n      direction: props.direction,\n      currentAnchor: currentAnchor,\n      addLink: addLink,\n      removeLink: removeLink,\n      handleClick: handleClick\n    });\n    expose({\n      scrollTo: scrollTo\n    });\n    return function (_ctx, _cache) {\n      return vue.openBlock(), vue.createElementBlock(\"div\", {\n        ref_key: \"anchorRef\",\n        ref: anchorRef,\n        \"class\": vue.normalizeClass(vue.unref(cls))\n      }, [_ctx.marker ? (vue.openBlock(), vue.createElementBlock(\"div\", {\n        key: 0,\n        ref_key: \"markerRef\",\n        ref: markerRef,\n        \"class\": vue.normalizeClass(vue.unref(ns).e(\"marker\")),\n        style: vue.normalizeStyle(vue.unref(markerStyle))\n      }, null, 6)) : vue.createCommentVNode(\"v-if\", true), vue.createElementVNode(\"div\", {\n        \"class\": vue.normalizeClass(vue.unref(ns).e(\"list\"))\n      }, [vue.renderSlot(_ctx.$slots, \"default\")], 2)], 2);\n    };\n  }\n}));\nvar Anchor = /* @__PURE__ */pluginVue_exportHelper[\"default\"](_sfc_main, [[\"__file\", \"anchor.vue\"]]);\nexports[\"default\"] = Anchor;","map":{"version":3,"names":["name","currentAnchor","vue","ref","anchorRef","markerRef","containerEl","links","isScrolling","currentScrollTop","ns","index","useNamespace","cls","computed","b","props","type","m","direction","addLink","state","href","el","removeLink","setCurrentAnchor","activeHref","value","emit","event","CHANGE_EVENT","clearAnimate","scrollToAnchor","target","element","getElement","scrollEle","scroll","getScrollElement","distance","position","getOffsetTopDistance","max","scrollHeight","clientHeight","to","Math","min","offset","animateScrollTo","duration","setTimeout","scrollTo","handleClick","e","handleScroll","throttleByRaf","getScrollTop","currentHref","getCurrentHref","types","isUndefined","scrollTop","anchorTopList","_i","_Object$keys","Object","keys","length","push","top","bound","sort","prev","next","i","item","selectScrollTop","getContainer","container","isWindow","window","core","useEventListener","markerStyle","currentLinkEl","anchorRect","getBoundingClientRect","markerRect","linkRect","left","concat","width","opacity","height","onMounted","hash","decodeURIComponent","location","watch","provide","constants","anchorKey","expose","_ctx","_cache"],"sources":["../../../../../../packages/components/anchor/src/anchor.vue"],"sourcesContent":["<template>\n  <div ref=\"anchorRef\" :class=\"cls\">\n    <div\n      v-if=\"marker\"\n      ref=\"markerRef\"\n      :class=\"ns.e('marker')\"\n      :style=\"markerStyle\"\n    />\n    <div :class=\"ns.e('list')\">\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, onMounted, provide, ref, watch } from 'vue'\nimport { useEventListener } from '@vueuse/core'\nimport { useNamespace } from '@element-plus/hooks'\nimport {\n  animateScrollTo,\n  getElement,\n  getOffsetTopDistance,\n  getScrollElement,\n  getScrollTop,\n  isUndefined,\n  isWindow,\n  throttleByRaf,\n} from '@element-plus/utils'\nimport { CHANGE_EVENT } from '@element-plus/constants'\nimport { anchorEmits, anchorProps } from './anchor'\nimport { anchorKey } from './constants'\n\nimport type { AnchorLinkState } from './constants'\n\ndefineOptions({\n  name: 'ElAnchor',\n})\n\nconst props = defineProps(anchorProps)\nconst emit = defineEmits(anchorEmits)\n\nconst currentAnchor = ref('')\nconst anchorRef = ref<HTMLElement | null>(null)\nconst markerRef = ref<HTMLElement | null>(null)\nconst containerEl = ref<HTMLElement | Window>()\n\nconst links: Record<string, HTMLElement> = {}\nlet isScrolling = false\nlet currentScrollTop = 0\n\nconst ns = useNamespace('anchor')\n\nconst cls = computed(() => [\n  ns.b(),\n  props.type === 'underline' ? ns.m('underline') : '',\n  ns.m(props.direction),\n])\n\nconst addLink = (state: AnchorLinkState) => {\n  links[state.href] = state.el\n}\n\nconst removeLink = (href: string) => {\n  delete links[href]\n}\n\nconst setCurrentAnchor = (href: string) => {\n  const activeHref = currentAnchor.value\n  if (activeHref !== href) {\n    currentAnchor.value = href\n    emit(CHANGE_EVENT, href)\n  }\n}\n\nlet clearAnimate: (() => void) | null = null\n\nconst scrollToAnchor = (href: string) => {\n  if (!containerEl.value) return\n  const target = getElement(href)\n  if (!target) return\n  if (clearAnimate) clearAnimate()\n  isScrolling = true\n  const scrollEle = getScrollElement(target, containerEl.value)\n  const distance = getOffsetTopDistance(target, scrollEle)\n  const max = scrollEle.scrollHeight - scrollEle.clientHeight\n  const to = Math.min(distance - props.offset, max)\n  clearAnimate = animateScrollTo(\n    containerEl.value,\n    currentScrollTop,\n    to,\n    props.duration,\n    () => {\n      // make sure it is executed after throttleByRaf's handleScroll\n      setTimeout(() => {\n        isScrolling = false\n      }, 20)\n    }\n  )\n}\n\nconst scrollTo = (href?: string) => {\n  if (href) {\n    setCurrentAnchor(href)\n    scrollToAnchor(href)\n  }\n}\n\nconst handleClick = (e: MouseEvent, href?: string) => {\n  emit('click', e, href)\n  scrollTo(href)\n}\n\nconst handleScroll = throttleByRaf(() => {\n  if (containerEl.value) {\n    currentScrollTop = getScrollTop(containerEl.value)\n  }\n  const currentHref = getCurrentHref()\n  if (isScrolling || isUndefined(currentHref)) return\n  setCurrentAnchor(currentHref)\n})\n\nconst getCurrentHref = () => {\n  if (!containerEl.value) return\n  const scrollTop = getScrollTop(containerEl.value)\n  const anchorTopList: { top: number; href: string }[] = []\n\n  for (const href of Object.keys(links)) {\n    const target = getElement(href)\n    if (!target) continue\n    const scrollEle = getScrollElement(target, containerEl.value)\n    const distance = getOffsetTopDistance(target, scrollEle)\n    anchorTopList.push({\n      top: distance - props.offset - props.bound,\n      href,\n    })\n  }\n  anchorTopList.sort((prev, next) => prev.top - next.top)\n  for (let i = 0; i < anchorTopList.length; i++) {\n    const item = anchorTopList[i]\n    const next = anchorTopList[i + 1]\n\n    if (i === 0 && scrollTop === 0) {\n      return props.selectScrollTop ? item.href : ''\n    }\n    if (item.top <= scrollTop && (!next || next.top > scrollTop)) {\n      return item.href\n    }\n  }\n}\n\nconst getContainer = () => {\n  const el = getElement(props.container)\n  if (!el || isWindow(el)) {\n    containerEl.value = window\n  } else {\n    containerEl.value = el\n  }\n}\n\nuseEventListener(containerEl, 'scroll', handleScroll)\n\nconst markerStyle = computed(() => {\n  if (!anchorRef.value || !markerRef.value || !currentAnchor.value) return {}\n  const currentLinkEl = links[currentAnchor.value]\n  if (!currentLinkEl) return {}\n  const anchorRect = anchorRef.value.getBoundingClientRect()\n  const markerRect = markerRef.value.getBoundingClientRect()\n  const linkRect = currentLinkEl.getBoundingClientRect()\n\n  if (props.direction === 'horizontal') {\n    const left = linkRect.left - anchorRect.left\n    return {\n      left: `${left}px`,\n      width: `${linkRect.width}px`,\n      opacity: 1,\n    }\n  } else {\n    const top =\n      linkRect.top - anchorRect.top + (linkRect.height - markerRect.height) / 2\n    return {\n      top: `${top}px`,\n      opacity: 1,\n    }\n  }\n})\n\nonMounted(() => {\n  getContainer()\n  const hash = decodeURIComponent(window.location.hash)\n  const target = getElement(hash)\n  if (target) {\n    scrollTo(hash)\n  } else {\n    handleScroll()\n  }\n})\n\nwatch(\n  () => props.container,\n  () => {\n    getContainer()\n  }\n)\n\nprovide(anchorKey, {\n  ns,\n  direction: props.direction,\n  currentAnchor,\n  addLink,\n  removeLink,\n  handleClick,\n})\n\ndefineExpose({\n  scrollTo,\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}