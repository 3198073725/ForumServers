{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/objectSpread2.js\")[\"default\"];\nvar _slicedToArray = require(\"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\nvar _defineProperty = require(\"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/defineProperty.js\")[\"default\"];\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.function.name.js\");\nrequire(\"core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vue = require('vue');\nvar core = require('@vueuse/core');\nvar useCache = require('../hooks/use-cache.js');\nvar useWheel = require('../hooks/use-wheel.js');\nvar scrollbar = require('../components/scrollbar.js');\nvar utils = require('../utils.js');\nvar props = require('../props.js');\nvar defaults = require('../defaults.js');\nvar index = require('../../../../hooks/use-namespace/index.js');\nvar types = require('../../../../utils/types.js');\nvar shared = require('@vue/shared');\nvar createList = function createList(_ref) {\n  var name = _ref.name,\n    getOffset = _ref.getOffset,\n    getItemSize = _ref.getItemSize,\n    getItemOffset = _ref.getItemOffset,\n    getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n    getStartIndexForOffset = _ref.getStartIndexForOffset,\n    getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n    initCache = _ref.initCache,\n    clearCache = _ref.clearCache,\n    validateProps = _ref.validateProps;\n  return vue.defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: props.virtualizedListProps,\n    emits: [defaults.ITEM_RENDER_EVT, defaults.SCROLL_EVT],\n    setup: function setup(props, _ref2) {\n      var emit = _ref2.emit,\n        expose = _ref2.expose;\n      validateProps(props);\n      var instance = vue.getCurrentInstance();\n      var ns = index.useNamespace(\"vl\");\n      var dynamicSizeCache = vue.ref(initCache(props, instance));\n      var getItemStyleCache = useCache.useCache();\n      var windowRef = vue.ref();\n      var innerRef = vue.ref();\n      var scrollbarRef = vue.ref();\n      var states = vue.ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: types.isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn\n      });\n      var itemsToRender = vue.computed(function () {\n        var total = props.total,\n          cache = props.cache;\n        var _vue$unref = vue.unref(states),\n          isScrolling = _vue$unref.isScrolling,\n          scrollDir = _vue$unref.scrollDir,\n          scrollOffset = _vue$unref.scrollOffset;\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        var startIndex = getStartIndexForOffset(props, scrollOffset, vue.unref(dynamicSizeCache));\n        var stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, vue.unref(dynamicSizeCache));\n        var cacheBackward = !isScrolling || scrollDir === defaults.BACKWARD ? Math.max(1, cache) : 1;\n        var cacheForward = !isScrolling || scrollDir === defaults.FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var estimatedTotalSize = vue.computed(function () {\n        return getEstimatedTotalSize(props, vue.unref(dynamicSizeCache));\n      });\n      var _isHorizontal = vue.computed(function () {\n        return utils.isHorizontal(props.layout);\n      });\n      var windowStyle = vue.computed(function () {\n        return [_defineProperty(_defineProperty(_defineProperty({\n          position: \"relative\"\n        }, \"overflow-\".concat(_isHorizontal.value ? \"x\" : \"y\"), \"scroll\"), \"WebkitOverflowScrolling\", \"touch\"), \"willChange\", \"transform\"), {\n          direction: props.direction,\n          height: types.isNumber(props.height) ? \"\".concat(props.height, \"px\") : props.height,\n          width: types.isNumber(props.width) ? \"\".concat(props.width, \"px\") : props.width\n        }, props.style];\n      });\n      var innerStyle = vue.computed(function () {\n        var size = vue.unref(estimatedTotalSize);\n        var horizontal = vue.unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : \"\".concat(size, \"px\"),\n          pointerEvents: vue.unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? \"\".concat(size, \"px\") : \"100%\"\n        };\n      });\n      var clientSize = vue.computed(function () {\n        return _isHorizontal.value ? props.width : props.height;\n      });\n      var _useWheel$default = useWheel[\"default\"]({\n          atStartEdge: vue.computed(function () {\n            return states.value.scrollOffset <= 0;\n          }),\n          atEndEdge: vue.computed(function () {\n            return states.value.scrollOffset >= estimatedTotalSize.value;\n          }),\n          layout: vue.computed(function () {\n            return props.layout;\n          })\n        }, function (offset) {\n          var _a, _b;\n          (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n          scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n        }),\n        onWheel = _useWheel$default.onWheel;\n      core.useEventListener(windowRef, \"wheel\", onWheel, {\n        passive: false\n      });\n      var emitEvents = function emitEvents() {\n        var total = props.total;\n        if (total > 0) {\n          var _vue$unref2 = vue.unref(itemsToRender),\n            _vue$unref3 = _slicedToArray(_vue$unref2, 4),\n            cacheStart = _vue$unref3[0],\n            cacheEnd = _vue$unref3[1],\n            visibleStart = _vue$unref3[2],\n            visibleEnd = _vue$unref3[3];\n          emit(defaults.ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        var _vue$unref4 = vue.unref(states),\n          scrollDir = _vue$unref4.scrollDir,\n          scrollOffset = _vue$unref4.scrollOffset,\n          updateRequested = _vue$unref4.updateRequested;\n        emit(defaults.SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      var scrollVertically = function scrollVertically(e) {\n        var _e$currentTarget = e.currentTarget,\n          clientHeight = _e$currentTarget.clientHeight,\n          scrollHeight = _e$currentTarget.scrollHeight,\n          scrollTop = _e$currentTarget.scrollTop;\n        var _states = vue.unref(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollDir: utils.getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset: scrollOffset,\n          updateRequested: false\n        });\n        vue.nextTick(resetIsScrolling);\n      };\n      var scrollHorizontally = function scrollHorizontally(e) {\n        var _e$currentTarget2 = e.currentTarget,\n          clientWidth = _e$currentTarget2.clientWidth,\n          scrollLeft = _e$currentTarget2.scrollLeft,\n          scrollWidth = _e$currentTarget2.scrollWidth;\n        var _states = vue.unref(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        var direction = props.direction;\n        var scrollOffset = scrollLeft;\n        if (direction === defaults.RTL) {\n          switch (utils.getRTLOffsetType()) {\n            case defaults.RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n            case defaults.RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollDir: utils.getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset: scrollOffset,\n          updateRequested: false\n        });\n        vue.nextTick(resetIsScrolling);\n      };\n      var onScroll = function onScroll(e) {\n        vue.unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      var onScrollbarScroll = function onScrollbarScroll(distanceToGo, totalSteps) {\n        var offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      var scrollTo = function scrollTo(offset) {\n        offset = Math.max(offset, 0);\n        if (offset === vue.unref(states).scrollOffset) {\n          return;\n        }\n        states.value = _objectSpread(_objectSpread({}, vue.unref(states)), {}, {\n          scrollOffset: offset,\n          scrollDir: utils.getScrollDir(vue.unref(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        vue.nextTick(resetIsScrolling);\n      };\n      var scrollToItem = function scrollToItem(idx) {\n        var alignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaults.AUTO_ALIGNMENT;\n        var _vue$unref5 = vue.unref(states),\n          scrollOffset = _vue$unref5.scrollOffset;\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, vue.unref(dynamicSizeCache)));\n      };\n      var getItemStyle = function getItemStyle(idx) {\n        var direction = props.direction,\n          itemSize = props.itemSize,\n          layout = props.layout;\n        var itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        var style;\n        if (shared.hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          var offset = getItemOffset(props, idx, vue.unref(dynamicSizeCache));\n          var size = getItemSize(props, idx, vue.unref(dynamicSizeCache));\n          var horizontal = vue.unref(_isHorizontal);\n          var isRtl = direction === defaults.RTL;\n          var offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : \"\".concat(offsetHorizontal, \"px\"),\n            right: isRtl ? \"\".concat(offsetHorizontal, \"px\") : void 0,\n            top: !horizontal ? \"\".concat(offset, \"px\") : 0,\n            height: !horizontal ? \"\".concat(size, \"px\") : \"100%\",\n            width: horizontal ? \"\".concat(size, \"px\") : \"100%\"\n          };\n        }\n        return style;\n      };\n      var resetIsScrolling = function resetIsScrolling() {\n        states.value.isScrolling = false;\n        vue.nextTick(function () {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      var resetScrollTop = function resetScrollTop() {\n        var window = windowRef.value;\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n      vue.onMounted(function () {\n        if (!core.isClient) return;\n        var initScrollOffset = props.initScrollOffset;\n        var windowElement = vue.unref(windowRef);\n        if (types.isNumber(initScrollOffset) && windowElement) {\n          if (vue.unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      vue.onUpdated(function () {\n        var direction = props.direction,\n          layout = props.layout;\n        var _vue$unref6 = vue.unref(states),\n          scrollOffset = _vue$unref6.scrollOffset,\n          updateRequested = _vue$unref6.updateRequested;\n        var windowElement = vue.unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (layout === defaults.HORIZONTAL) {\n            if (direction === defaults.RTL) {\n              switch (utils.getRTLOffsetType()) {\n                case defaults.RTL_OFFSET_NAG:\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n                case defaults.RTL_OFFSET_POS_ASC:\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n                default:\n                  {\n                    var clientWidth = windowElement.clientWidth,\n                      scrollWidth = windowElement.scrollWidth;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      vue.onActivated(function () {\n        vue.unref(windowRef).scrollTop = vue.unref(states).scrollOffset;\n      });\n      var api = {\n        ns: ns,\n        clientSize: clientSize,\n        estimatedTotalSize: estimatedTotalSize,\n        windowStyle: windowStyle,\n        windowRef: windowRef,\n        innerRef: innerRef,\n        innerStyle: innerStyle,\n        itemsToRender: itemsToRender,\n        scrollbarRef: scrollbarRef,\n        states: states,\n        getItemStyle: getItemStyle,\n        onScroll: onScroll,\n        onScrollbarScroll: onScrollbarScroll,\n        onWheel: onWheel,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        resetScrollTop: resetScrollTop\n      };\n      expose({\n        windowRef: windowRef,\n        innerRef: innerRef,\n        getItemStyleCache: getItemStyleCache,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        resetScrollTop: resetScrollTop,\n        states: states\n      });\n      return api;\n    },\n    render: function render(ctx) {\n      var _a;\n      var $slots = ctx.$slots,\n        className = ctx.className,\n        clientSize = ctx.clientSize,\n        containerElement = ctx.containerElement,\n        data = ctx.data,\n        getItemStyle = ctx.getItemStyle,\n        innerElement = ctx.innerElement,\n        itemsToRender = ctx.itemsToRender,\n        innerStyle = ctx.innerStyle,\n        layout = ctx.layout,\n        total = ctx.total,\n        onScroll = ctx.onScroll,\n        onScrollbarScroll = ctx.onScrollbarScroll,\n        states = ctx.states,\n        useIsScrolling = ctx.useIsScrolling,\n        windowStyle = ctx.windowStyle,\n        ns = ctx.ns;\n      var _itemsToRender = _slicedToArray(itemsToRender, 2),\n        start = _itemsToRender[0],\n        end = _itemsToRender[1];\n      var Container = vue.resolveDynamicComponent(containerElement);\n      var Inner = vue.resolveDynamicComponent(innerElement);\n      var children = [];\n      if (total > 0) {\n        for (var i = start; i <= end; i++) {\n          children.push(vue.h(vue.Fragment, {\n            key: i\n          }, (_a = $slots[\"default\"]) == null ? void 0 : _a.call($slots, {\n            data: data,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          })));\n        }\n      }\n      var InnerNode = [vue.h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !shared.isString(Inner) ? {\n        \"default\": function _default() {\n          return children;\n        }\n      } : children)];\n      var scrollbar$1 = vue.h(scrollbar[\"default\"], {\n        ref: \"scrollbarRef\",\n        clientSize: clientSize,\n        layout: layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total: total\n      });\n      var listContainer = vue.h(Container, {\n        \"class\": [ns.e(\"window\"), className],\n        style: windowStyle,\n        onScroll: onScroll,\n        ref: \"windowRef\",\n        key: 0\n      }, !shared.isString(Container) ? {\n        \"default\": function _default() {\n          return [InnerNode];\n        }\n      } : [InnerNode]);\n      return vue.h(\"div\", {\n        key: 0,\n        \"class\": [ns.e(\"wrapper\"), states.scrollbarAlwaysOn ? \"always-on\" : \"\"]\n      }, [listContainer, scrollbar$1]);\n    }\n  });\n};\nexports[\"default\"] = createList;","map":{"version":3,"names":["createList","_ref","name","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","initCache","clearCache","validateProps","vue","defineComponent","props","virtualizedListProps","emits","defaults","ITEM_RENDER_EVT","SCROLL_EVT","setup","_ref2","emit","expose","instance","getCurrentInstance","ns","index","useNamespace","dynamicSizeCache","ref","getItemStyleCache","useCache","windowRef","innerRef","scrollbarRef","states","isScrolling","scrollDir","scrollOffset","types","isNumber","initScrollOffset","updateRequested","isScrollbarDragging","scrollbarAlwaysOn","itemsToRender","computed","total","cache","_vue$unref","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","FORWARD","min","estimatedTotalSize","_isHorizontal","utils","isHorizontal","layout","windowStyle","_defineProperty","position","concat","value","direction","height","width","style","innerStyle","size","horizontal","pointerEvents","clientSize","_useWheel$default","useWheel","atStartEdge","atEndEdge","offset","_a","_b","onMouseUp","call","scrollTo","onWheel","core","useEventListener","passive","emitEvents","_vue$unref2","_vue$unref3","_slicedToArray","cacheStart","cacheEnd","visibleStart","visibleEnd","_vue$unref4","scrollVertically","e","_e$currentTarget","currentTarget","clientHeight","scrollHeight","scrollTop","_states","_objectSpread","getScrollDir","nextTick","resetIsScrolling","scrollHorizontally","_e$currentTarget2","clientWidth","scrollLeft","scrollWidth","RTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","onScroll","onScrollbarScroll","distanceToGo","totalSteps","scrollToItem","idx","alignment","arguments","length","undefined","AUTO_ALIGNMENT","_vue$unref5","getItemStyle","itemSize","itemStyleCache","shared","hasOwn","String","isRtl","offsetHorizontal","left","right","top","resetScrollTop","window","onMounted","isClient","windowElement","onUpdated","_vue$unref6","HORIZONTAL","RTL_OFFSET_POS_ASC","onActivated","api","render","ctx","$slots","className","containerElement","data","innerElement","useIsScrolling","_itemsToRender","start","end","Container","resolveDynamicComponent","Inner","children","i","push","h","Fragment","key","InnerNode","isString","default","scrollbar$1","scrollbar","ratio","scrollFrom","listContainer"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-list.ts"],"sourcesContent":["import {\n  Fragment,\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  nextTick,\n  onActivated,\n  onMounted,\n  onUpdated,\n  ref,\n  resolveDynamicComponent,\n  unref,\n} from 'vue'\nimport { useEventListener } from '@vueuse/core'\nimport { hasOwn, isClient, isNumber, isString } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { useCache } from '../hooks/use-cache'\nimport useWheel from '../hooks/use-wheel'\nimport Scrollbar from '../components/scrollbar'\nimport { getRTLOffsetType, getScrollDir, isHorizontal } from '../utils'\nimport { virtualizedListProps } from '../props'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  HORIZONTAL,\n  ITEM_RENDER_EVT,\n  RTL,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_ASC,\n  RTL_OFFSET_POS_DESC,\n  SCROLL_EVT,\n} from '../defaults'\n\nimport type { CSSProperties, Slot, VNode, VNodeChild } from 'vue'\nimport type { Alignment, ListConstructorProps } from '../types'\nimport type { VirtualizedListProps } from '../props'\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps,\n}: ListConstructorProps<VirtualizedListProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props)\n      const instance = getCurrentInstance()!\n\n      const ns = useNamespace('vl')\n\n      const dynamicSizeCache = ref(initCache(props, instance))\n\n      const getItemStyleCache = useCache<CSSProperties>()\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const innerRef = ref<HTMLElement>()\n      const scrollbarRef = ref()\n      const states = ref({\n        isScrolling: false,\n        scrollDir: 'forward',\n        scrollOffset: isNumber(props.initScrollOffset)\n          ? props.initScrollOffset\n          : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn,\n      })\n\n      // computed\n      const itemsToRender = computed(() => {\n        const { total, cache } = props\n        const { isScrolling, scrollDir, scrollOffset } = unref(states)\n\n        if (total === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getStartIndexForOffset(\n          props,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n        const stopIndex = getStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n\n        const cacheBackward =\n          !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1\n        const cacheForward =\n          !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalSize = computed(() =>\n        getEstimatedTotalSize(props, unref(dynamicSizeCache))\n      )\n\n      const _isHorizontal = computed(() => isHorizontal(props.layout))\n\n      const windowStyle = computed(() => [\n        {\n          position: 'relative',\n          [`overflow-${_isHorizontal.value ? 'x' : 'y'}`]: 'scroll',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style,\n      ])\n\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize)\n        const horizontal = unref(_isHorizontal)\n        return {\n          height: horizontal ? '100%' : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width: horizontal ? `${size}px` : '100%',\n        }\n      })\n\n      const clientSize = computed(() =>\n        _isHorizontal.value ? props.width : props.height\n      )\n\n      // methods\n      const { onWheel } = useWheel(\n        {\n          atStartEdge: computed(() => states.value.scrollOffset <= 0),\n          atEndEdge: computed(\n            () => states.value.scrollOffset >= estimatedTotalSize.value\n          ),\n          layout: computed(() => props.layout),\n        },\n        (offset) => {\n          ;(\n            scrollbarRef.value as {\n              onMouseUp: () => void\n            }\n          ).onMouseUp?.()\n          scrollTo(\n            Math.min(\n              states.value.scrollOffset + offset,\n              estimatedTotalSize.value - (clientSize.value as number)\n            )\n          )\n        }\n      )\n\n      useEventListener(windowRef, 'wheel', onWheel, {\n        passive: false,\n      })\n\n      const emitEvents = () => {\n        const { total } = props\n\n        if (total! > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] =\n            unref(itemsToRender)\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd)\n        }\n\n        const { scrollDir, scrollOffset, updateRequested } = unref(states)\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested)\n      }\n\n      const scrollVertically = (e: Event) => {\n        const { clientHeight, scrollHeight, scrollTop } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n        if (_states.scrollOffset === scrollTop) {\n          return\n        }\n\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollHorizontally = (e: Event) => {\n        const { clientWidth, scrollLeft, scrollWidth } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n\n        if (_states.scrollOffset === scrollLeft) {\n          return\n        }\n\n        const { direction } = props\n\n        let scrollOffset = scrollLeft\n\n        if (direction === RTL) {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft\n              break\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft\n              break\n            }\n          }\n        }\n\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const onScroll = (e: Event) => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e)\n        emitEvents()\n      }\n\n      const onScrollbarScroll = (distanceToGo: number, totalSteps: number) => {\n        const offset =\n          ((estimatedTotalSize.value - (clientSize.value as number)) /\n            totalSteps) *\n          distanceToGo\n        scrollTo(\n          Math.min(\n            estimatedTotalSize.value - (clientSize.value as number),\n            offset\n          )\n        )\n      }\n\n      const scrollTo = (offset: number) => {\n        offset = Math.max(offset, 0)\n\n        if (offset === unref(states).scrollOffset) {\n          return\n        }\n\n        states.value = {\n          ...unref(states),\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollToItem = (\n        idx: number,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const { scrollOffset } = unref(states)\n\n        idx = Math.max(0, Math.min(idx, props.total! - 1))\n        scrollTo(\n          getOffset(\n            props,\n            idx,\n            alignment,\n            scrollOffset,\n            unref(dynamicSizeCache)\n          )\n        )\n      }\n\n      const getItemStyle = (idx: number) => {\n        const { direction, itemSize, layout } = props\n\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && itemSize,\n          clearCache && layout,\n          clearCache && direction\n        )\n\n        let style: CSSProperties\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx]\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache))\n          const size = getItemSize(props, idx, unref(dynamicSizeCache))\n          const horizontal = unref(_isHorizontal)\n\n          const isRtl = direction === RTL\n          const offsetHorizontal = horizontal ? offset : 0\n          itemStyleCache[idx] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : undefined,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : '100%',\n            width: horizontal ? `${size}px` : '100%',\n          }\n        }\n\n        return style\n      }\n\n      // TODO: perf optimization here, reset isScrolling with debounce.\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      const resetScrollTop = () => {\n        const window = windowRef.value\n        if (window) {\n          window.scrollTop = 0\n        }\n      }\n\n      // life cycles\n      onMounted(() => {\n        if (!isClient) return\n        const { initScrollOffset } = props\n        const windowElement = unref(windowRef)\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset\n          } else {\n            windowElement.scrollTop = initScrollOffset\n          }\n        }\n\n        emitEvents()\n      })\n\n      onUpdated(() => {\n        const { direction, layout } = props\n        const { scrollOffset, updateRequested } = unref(states)\n        const windowElement = unref(windowRef)\n\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n              // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n              // So we need to determine which browser behavior we're dealing with, and mimic it.\n              switch (getRTLOffsetType()) {\n                case RTL_OFFSET_NAG: {\n                  windowElement.scrollLeft = -scrollOffset\n                  break\n                }\n                case RTL_OFFSET_POS_ASC: {\n                  windowElement.scrollLeft = scrollOffset\n                  break\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement\n                  windowElement.scrollLeft =\n                    scrollWidth - clientWidth - scrollOffset\n                  break\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset\n          }\n        }\n      })\n\n      onActivated(() => {\n        unref(windowRef)!.scrollTop = unref(states).scrollOffset\n      })\n\n      const api = {\n        ns,\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n      }\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states,\n      })\n\n      return api\n    },\n\n    render(ctx: any) {\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        states,\n        useIsScrolling,\n        windowStyle,\n        ns,\n      } = ctx\n\n      const [start, end] = itemsToRender\n\n      const Container = resolveDynamicComponent(containerElement)\n      const Inner = resolveDynamicComponent(innerElement)\n\n      const children = [] as VNodeChild[]\n\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push(\n            h(\n              Fragment,\n              { key: i },\n              ($slots.default as Slot)?.({\n                data,\n                index: i,\n                isScrolling: useIsScrolling ? states.isScrolling : undefined,\n                style: getItemStyle(i),\n              })\n            )\n          )\n        }\n      }\n\n      const InnerNode = [\n        h(\n          Inner as VNode,\n          {\n            style: innerStyle,\n            ref: 'innerRef',\n          },\n          !isString(Inner)\n            ? {\n                default: () => children,\n              }\n            : children\n        ),\n      ]\n\n      const scrollbar = h(Scrollbar, {\n        ref: 'scrollbarRef',\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: (clientSize * 100) / this.estimatedTotalSize,\n        scrollFrom:\n          states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n      })\n\n      const listContainer = h(\n        Container as VNode,\n        {\n          class: [ns.e('window'), className],\n          style: windowStyle,\n          onScroll,\n          ref: 'windowRef',\n          key: 0,\n        },\n        !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]\n      )\n\n      return h(\n        'div',\n        {\n          key: 0,\n          class: [ns.e('wrapper'), states.scrollbarAlwaysOn ? 'always-on' : ''],\n        },\n        [listContainer, scrollbar]\n      )\n    },\n  })\n}\n\nexport default createList\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}