{"ast":null,"code":"'use strict';\n\nvar _typeof = require(\"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\nrequire(\"core-js/modules/es.number.constructor.js\");\nrequire(\"core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar buildGrid = require('../builders/build-grid.js');\nvar defaults = require('../defaults.js');\nvar types = require('../../../../utils/types.js');\nvar error = require('../../../../utils/error.js');\nvar SCOPE = \"ElFixedSizeGrid\";\nvar FixedSizeGrid = buildGrid[\"default\"]({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: function getColumnPosition(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return [columnWidth, index * columnWidth];\n  },\n  getRowPosition: function getRowPosition(_ref2, index) {\n    var rowHeight = _ref2.rowHeight;\n    return [rowHeight, index * rowHeight];\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref3) {\n    var totalRow = _ref3.totalRow,\n      rowHeight = _ref3.rowHeight;\n    return rowHeight * totalRow;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref4) {\n    var totalColumn = _ref4.totalColumn,\n      columnWidth = _ref4.columnWidth;\n    return columnWidth * totalColumn;\n  },\n  getColumnOffset: function getColumnOffset(_ref5, columnIndex, alignment, scrollLeft, _, scrollBarWidth) {\n    var totalColumn = _ref5.totalColumn,\n      columnWidth = _ref5.columnWidth,\n      width = _ref5.width;\n    width = Number(width);\n    var lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = defaults.AUTO_ALIGNMENT;\n      } else {\n        alignment = defaults.CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case defaults.START_ALIGNMENT:\n        return maxOffset;\n      case defaults.END_ALIGNMENT:\n        return minOffset;\n      case defaults.CENTERED_ALIGNMENT:\n        {\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n          if (middleOffset < Math.ceil(width / 2)) {\n            return 0;\n          } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n            return lastColumnOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n      case defaults.AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getRowOffset: function getRowOffset(_ref6, rowIndex, align, scrollTop, _, scrollBarWidth) {\n    var rowHeight = _ref6.rowHeight,\n      height = _ref6.height,\n      totalRow = _ref6.totalRow;\n    height = Number(height);\n    var lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n    if (align === defaults.SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = defaults.AUTO_ALIGNMENT;\n      } else {\n        align = defaults.CENTERED_ALIGNMENT;\n      }\n    }\n    switch (align) {\n      case defaults.START_ALIGNMENT:\n        return maxOffset;\n      case defaults.END_ALIGNMENT:\n        return minOffset;\n      case defaults.CENTERED_ALIGNMENT:\n        {\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n          if (middleOffset < Math.ceil(height / 2)) {\n            return 0;\n          } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n            return lastRowOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n      case defaults.AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref7, scrollLeft) {\n    var columnWidth = _ref7.columnWidth,\n      totalColumn = _ref7.totalColumn;\n    return Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref8, startIndex, scrollLeft) {\n    var columnWidth = _ref8.columnWidth,\n      totalColumn = _ref8.totalColumn,\n      width = _ref8.width;\n    var left = startIndex * columnWidth;\n    var visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref9, scrollTop) {\n    var rowHeight = _ref9.rowHeight,\n      totalRow = _ref9.totalRow;\n    return Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref0, startIndex, scrollTop) {\n    var rowHeight = _ref0.rowHeight,\n      totalRow = _ref0.totalRow,\n      height = _ref0.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: function initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps: function validateProps(_ref1) {\n    var columnWidth = _ref1.columnWidth,\n      rowHeight = _ref1.rowHeight;\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!types.isNumber(columnWidth)) {\n        error.throwError(SCOPE, \"\\n          \\\"columnWidth\\\" must be passed as number,\\n            instead \".concat(_typeof(columnWidth), \" was given.\\n        \"));\n      }\n      if (!types.isNumber(rowHeight)) {\n        error.throwError(SCOPE, \"\\n          \\\"columnWidth\\\" must be passed as number,\\n            instead \".concat(_typeof(rowHeight), \" was given.\\n        \"));\n      }\n    }\n  }\n});\nexports[\"default\"] = FixedSizeGrid;","map":{"version":3,"names":["SCOPE","FixedSizeGrid","buildGrid","name","getColumnPosition","_ref","index","columnWidth","getRowPosition","_ref2","rowHeight","getEstimatedTotalHeight","_ref3","totalRow","getEstimatedTotalWidth","_ref4","totalColumn","getColumnOffset","_ref5","columnIndex","alignment","scrollLeft","_","scrollBarWidth","width","Number","lastColumnOffset","Math","max","maxOffset","min","minOffset","defaults","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","middleOffset","round","ceil","floor","getRowOffset","_ref6","rowIndex","align","scrollTop","height","lastRowOffset","SMART_ALIGNMENT","getColumnStartIndexForOffset","_ref7","getColumnStopIndexForStartIndex","_ref8","startIndex","left","visibleColumnsCount","getRowStartIndexForOffset","_ref9","getRowStopIndexForStartIndex","_ref0","top","numVisibleRows","initCache","clearCache","validateProps","_ref1","process","env","NODE_ENV","types","isNumber","error","throwError","concat","_typeof"],"sources":["../../../../../../../packages/components/virtual-list/src/components/fixed-size-grid.ts"],"sourcesContent":["import { isNumber, throwError } from '@element-plus/utils'\nimport createGrid from '../builders/build-grid'\n\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\n\nconst SCOPE = 'ElFixedSizeGrid'\n\nconst FixedSizeGrid = createGrid({\n  name: 'ElFixedSizeGrid',\n  getColumnPosition: ({ columnWidth }, index) => [\n    columnWidth as number,\n    index * (columnWidth as number),\n  ],\n\n  getRowPosition: ({ rowHeight }, index) => [\n    rowHeight as number,\n    index * (rowHeight as number),\n  ],\n\n  getEstimatedTotalHeight: ({ totalRow, rowHeight }) =>\n    (rowHeight as number) * totalRow,\n\n  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) =>\n    (columnWidth as number) * totalColumn,\n\n  getColumnOffset: (\n    { totalColumn, columnWidth, width },\n    columnIndex,\n    alignment,\n    scrollLeft,\n    _,\n    scrollBarWidth\n  ) => {\n    width = Number(width)\n    const lastColumnOffset = Math.max(\n      0,\n      totalColumn * (columnWidth as number) - width\n    )\n    const maxOffset = Math.min(\n      lastColumnOffset,\n      columnIndex * (columnWidth as number)\n    )\n    const minOffset = Math.max(\n      0,\n      columnIndex * (columnWidth as number) -\n        width +\n        scrollBarWidth +\n        (columnWidth as number)\n    )\n\n    if (alignment === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset\n      case END_ALIGNMENT:\n        return minOffset\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft\n        } else if (minOffset > maxOffset) {\n          return minOffset\n        } else if (scrollLeft < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n    }\n  },\n\n  getRowOffset: (\n    { rowHeight, height, totalRow },\n    rowIndex,\n    align,\n    scrollTop,\n    _,\n    scrollBarWidth\n  ): number => {\n    height = Number(height)\n    const lastRowOffset = Math.max(0, totalRow * (rowHeight as number) - height)\n    const maxOffset = Math.min(lastRowOffset, rowIndex * (rowHeight as number))\n    const minOffset = Math.max(\n      0,\n      rowIndex * (rowHeight as number) -\n        height +\n        scrollBarWidth +\n        (rowHeight as number)\n    )\n\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT\n      } else {\n        align = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset\n      case END_ALIGNMENT:\n        return minOffset\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop\n        } else if (minOffset > maxOffset) {\n          return minOffset\n        } else if (scrollTop < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n    }\n  },\n\n  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) =>\n    Math.max(\n      0,\n      Math.min(\n        totalColumn - 1,\n        Math.floor(scrollLeft / (columnWidth as number))\n      )\n    ),\n\n  getColumnStopIndexForStartIndex: (\n    { columnWidth, totalColumn, width },\n    startIndex: number,\n    scrollLeft: number\n  ): number => {\n    const left = startIndex * (columnWidth as number)\n    const visibleColumnsCount = Math.ceil(\n      ((width as number) + scrollLeft - left) / (columnWidth as number)\n    )\n    return Math.max(\n      0,\n      Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1)\n    )\n  },\n\n  getRowStartIndexForOffset: (\n    { rowHeight, totalRow },\n    scrollTop: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(totalRow - 1, Math.floor(scrollTop / (rowHeight as number)))\n    ),\n\n  getRowStopIndexForStartIndex: (\n    { rowHeight, totalRow, height },\n    startIndex: number,\n    scrollTop: number\n  ): number => {\n    const top = startIndex * (rowHeight as number)\n    const numVisibleRows = Math.ceil(\n      ((height as number) + scrollTop - top) / (rowHeight as number)\n    )\n    return Math.max(\n      0,\n      Math.min(\n        totalRow - 1,\n        startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n      )\n    )\n  },\n  /**\n   * Fixed size grid does not need this cache\n   * Using any to bypass it, TODO: Using type inference to fix this.\n   */\n  initCache: () => undefined as any,\n\n  clearCache: true,\n\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isNumber(columnWidth)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `\n        )\n      }\n\n      if (!isNumber(rowHeight)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default FixedSizeGrid\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}