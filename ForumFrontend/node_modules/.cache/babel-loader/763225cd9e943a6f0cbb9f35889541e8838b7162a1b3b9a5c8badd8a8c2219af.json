{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar buildList = require('../builders/build-list.js');\nvar utils = require('../utils.js');\nvar defaults = require('../defaults.js');\nvar shared = require('@vue/shared');\nvar error = require('../../../../utils/error.js');\nvar FixedSizeList = buildList[\"default\"]({\n  name: \"ElFixedSizeList\",\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var total = _ref3.total,\n      itemSize = _ref3.itemSize;\n    return itemSize * total;\n  },\n  getOffset: function getOffset(_ref4, index, alignment, scrollOffset) {\n    var height = _ref4.height,\n      total = _ref4.total,\n      itemSize = _ref4.itemSize,\n      layout = _ref4.layout,\n      width = _ref4.width;\n    var size = utils.isHorizontal(layout) ? width : height;\n    if (process.env.NODE_ENV !== \"production\" && shared.isString(size)) {\n      error.throwError(\"[ElVirtualList]\", \"\\n        You should set\\n          width/height\\n        to number when your layout is\\n          horizontal/vertical\\n      \");\n    }\n    var lastItemOffset = Math.max(0, total * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, (index + 1) * itemSize - size);\n    if (alignment === defaults.SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = defaults.AUTO_ALIGNMENT;\n      } else {\n        alignment = defaults.CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case defaults.START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n      case defaults.END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n      case defaults.CENTERED_ALIGNMENT:\n        {\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0;\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n      case defaults.AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var total = _ref5.total,\n      itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var height = _ref6.height,\n      total = _ref6.total,\n      itemSize = _ref6.itemSize,\n      layout = _ref6.layout,\n      width = _ref6.width;\n    var offset = startIndex * itemSize;\n    var size = utils.isHorizontal(layout) ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n  initCache: function initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps: function validateProps() {}\n});\nexports[\"default\"] = FixedSizeList;","map":{"version":3,"names":["FixedSizeList","buildList","name","getItemOffset","_ref","index","itemSize","getItemSize","_ref2","getEstimatedTotalSize","_ref3","total","getOffset","_ref4","alignment","scrollOffset","height","layout","width","size","utils","isHorizontal","process","env","NODE_ENV","shared","isString","error","throwError","lastItemOffset","Math","max","maxOffset","min","minOffset","defaults","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","middleOffset","round","ceil","floor","getStartIndexForOffset","_ref5","offset","getStopIndexForStartIndex","_ref6","startIndex","numVisibleItems","initCache","clearCache","validateProps"],"sources":["../../../../../../../packages/components/virtual-list/src/components/fixed-size-list.ts"],"sourcesContent":["import { isString, throwError } from '@element-plus/utils'\nimport buildList from '../builders/build-list'\nimport { isHorizontal } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\n\nimport type { VirtualizedListProps } from '../props'\n\ntype Props = VirtualizedListProps\n\nconst FixedSizeList = buildList({\n  name: 'ElFixedSizeList',\n  getItemOffset: ({ itemSize }, index) => index * (itemSize as number),\n\n  getItemSize: ({ itemSize }) => itemSize as number,\n\n  getEstimatedTotalSize: ({ total, itemSize }) => (itemSize as number) * total,\n\n  getOffset: (\n    { height, total, itemSize, layout, width },\n    index,\n    alignment,\n    scrollOffset\n  ) => {\n    const size = (isHorizontal(layout) ? width : height) as number\n    if (process.env.NODE_ENV !== 'production' && isString(size)) {\n      throwError(\n        '[ElVirtualList]',\n        `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `\n      )\n    }\n    const lastItemOffset = Math.max(0, total * (itemSize as number) - size)\n    const maxOffset = Math.min(lastItemOffset, index * (itemSize as number))\n    const minOffset = Math.max(0, (index + 1) * (itemSize as number) - size)\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset\n      }\n      case END_ALIGNMENT: {\n        return minOffset\n      }\n      case CENTERED_ALIGNMENT: {\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2)\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0 // near the beginning\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset // near the end\n        } else {\n          return middleOffset\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset\n        } else if (scrollOffset < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n      }\n    }\n  },\n\n  getStartIndexForOffset: ({ total, itemSize }, offset) =>\n    Math.max(0, Math.min(total - 1, Math.floor(offset / (itemSize as number)))),\n\n  getStopIndexForStartIndex: (\n    { height, total, itemSize, layout, width }: Props,\n    startIndex: number,\n    scrollOffset: number\n  ) => {\n    const offset = startIndex * (itemSize as number)\n    const size = isHorizontal(layout) ? width : height\n    const numVisibleItems = Math.ceil(\n      ((size as number) + scrollOffset - offset) / (itemSize as number)\n    )\n    return Math.max(\n      0,\n      Math.min(\n        total - 1,\n        // because startIndex is inclusive, so in order to prevent array outbound indexing\n        // we need to - 1 to prevent outbound behavior\n        startIndex + numVisibleItems - 1\n      )\n    )\n  },\n\n  /**\n   * Fixed size list does not need this cache\n   * Using any to bypass it, TODO: Using type inference to fix this.\n   */\n  initCache() {\n    return undefined as any\n  },\n\n  clearCache: true,\n\n  validateProps() {},\n})\n\nexport type FixedSizeListInstance = InstanceType<typeof FixedSizeList> & unknown\nexport default FixedSizeList\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}