{"ast":null,"code":"import _classCallCheck from \"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\nimport ReconnectingWebSocket from 'reconnecting-websocket';\nimport store from '@/store';\nimport { ElMessage } from 'element-plus';\n\n// WebSocket基础URL - 根据环境配置\nvar WS_BASE_URL = process.env.NODE_ENV === 'production' ? 'wss://yourserver.com/ws' : 'ws://localhost:8001/ws';\n\n// WebSocket配置\nvar WS_CONFIG = {\n  connectionTimeout: 5000,\n  maxRetries: 10,\n  maxReconnectionDelay: 5000,\n  minReconnectionDelay: 1000,\n  debug: false,\n  wsOptions: {\n    origin: window.location.origin\n  }\n};\n\n/**\n * WebSocket管理类\n * 负责管理通知和聊天的WebSocket连接\n */\nvar WebSocketManager = /*#__PURE__*/function () {\n  function WebSocketManager() {\n    _classCallCheck(this, WebSocketManager);\n    this.notificationSocket = null;\n    this.chatSockets = {};\n    this.token = null;\n    this.connectionAttempts = 0;\n    this.maxConnectionAttempts = 5;\n  }\n\n  /**\n   * 初始化WebSocket连接\n   * @param {string} token - JWT令牌\n   */\n  return _createClass(WebSocketManager, [{\n    key: \"init\",\n    value: function init(token) {\n      // 重置连接尝试次数\n      this.connectionAttempts = 0;\n\n      // 保存或获取token\n      this.token = token || localStorage.getItem('token');\n      if (!this.token) {\n        console.log('无法获取令牌，不建立WebSocket连接');\n        return;\n      }\n\n      // 检查通知API是否可用\n      this._checkNotificationApiAvailability();\n    }\n\n    /**\n     * 检查通知API是否可用\n     * @private\n     */\n  }, {\n    key: \"_checkNotificationApiAvailability\",\n    value: function _checkNotificationApiAvailability() {\n      var _this = this;\n      fetch(\"\".concat(window.location.protocol, \"//\").concat(window.location.host, \"/api/v1/notifications/\"), {\n        headers: {\n          'Authorization': \"Bearer \".concat(this.token)\n        }\n      }).then(function (response) {\n        if (response.status !== 404) {\n          _this.connectNotification(_this.token);\n        } else {\n          console.log('通知接口不可用，不建立WebSocket连接');\n        }\n      })[\"catch\"](function (error) {\n        console.error('检查通知接口可用性失败:', error);\n\n        // 如果是网络问题，稍后重试\n        if (_this.connectionAttempts < _this.maxConnectionAttempts) {\n          _this.connectionAttempts++;\n          setTimeout(function () {\n            return _this._checkNotificationApiAvailability();\n          }, 3000);\n        }\n      });\n    }\n\n    /**\n     * 连接到通知WebSocket\n     * @param {string} token - JWT令牌\n     */\n  }, {\n    key: \"connectNotification\",\n    value: function connectNotification(token) {\n      // 关闭现有连接\n      if (this.notificationSocket) {\n        this.notificationSocket.close();\n        this.notificationSocket = null;\n      }\n\n      // 检查WebSocket功能是否已被禁用\n      if (window.webSocketEnabled === false) {\n        console.log('WebSocket功能已被禁用，不再尝试连接');\n        return;\n      }\n      try {\n        // 从Bearer token中提取实际的token\n        var rawToken = token.replace('Bearer ', '');\n\n        // 创建通知WebSocket连接\n        this.notificationSocket = new ReconnectingWebSocket(\"\".concat(WS_BASE_URL, \"/notifications/?token=\").concat(encodeURIComponent(rawToken)), [], WS_CONFIG);\n\n        // 设置事件处理器\n        this._setupNotificationSocketHandlers();\n      } catch (error) {\n        console.error('创建通知WebSocket连接失败:', error);\n      }\n    }\n\n    /**\n     * 设置通知WebSocket的事件处理器\n     * @private\n     */\n  }, {\n    key: \"_setupNotificationSocketHandlers\",\n    value: function _setupNotificationSocketHandlers() {\n      var _this2 = this;\n      // 连接打开时的处理\n      this.notificationSocket.onopen = function () {\n        console.log('通知WebSocket连接已建立');\n        // 重置连接尝试次数\n        _this2.connectionAttempts = 0;\n      };\n\n      // 接收消息的处理\n      this.notificationSocket.onmessage = function (event) {\n        try {\n          var data = JSON.parse(event.data);\n          _this2._handleNotificationMessage(data);\n        } catch (error) {\n          console.error('解析通知消息失败:', error);\n        }\n      };\n\n      // 连接关闭时的处理\n      this.notificationSocket.onclose = function () {\n        console.log('通知WebSocket连接已关闭');\n      };\n\n      // 连接错误时的处理\n      this.notificationSocket.onerror = function (error) {\n        console.error('通知WebSocket连接错误:', error);\n\n        // 连接错误次数过多时，禁用WebSocket功能\n        if (++_this2.connectionAttempts >= _this2.maxConnectionAttempts) {\n          console.log(\"\\u8FDE\\u63A5\\u5C1D\\u8BD5\\u6B21\\u6570(\".concat(_this2.connectionAttempts, \")\\u8FBE\\u5230\\u4E0A\\u9650\\uFF0C\\u7981\\u7528WebSocket\\u529F\\u80FD\"));\n          window.webSocketEnabled = false;\n        }\n      };\n    }\n\n    /**\n     * 处理通知消息\n     * @param {Object} data - 消息数据\n     * @private\n     */\n  }, {\n    key: \"_handleNotificationMessage\",\n    value: function _handleNotificationMessage(data) {\n      switch (data.type) {\n        case 'connection_established':\n          console.log(data.message);\n          break;\n        case 'unread_count':\n          // 更新未读通知数量\n          store.commit('notifications/setUnreadCount', data.count);\n          break;\n        case 'notification':\n          // 处理新通知\n          store.commit('notifications/addNotification', data);\n          store.commit('notifications/incrementUnreadCount');\n\n          // 显示通知提示\n          ElMessage({\n            message: data.title,\n            type: 'info',\n            duration: 3000\n          });\n          break;\n        case 'mark_read_response':\n        case 'mark_all_read_response':\n          // 标记通知已读的响应处理\n          break;\n        default:\n          console.log('未知的通知类型:', data.type);\n      }\n    }\n\n    /**\n     * 连接到聊天WebSocket\n     * @param {number} userId - 对方用户ID\n     */\n  }, {\n    key: \"connectChat\",\n    value: function connectChat(userId) {\n      if (!this.token) {\n        console.error('未登录，无法建立聊天连接');\n        return;\n      }\n\n      // 如果已存在与该用户的连接，则返回\n      if (this.chatSockets[userId]) {\n        return;\n      }\n      try {\n        // 从Bearer token中提取实际的token\n        var rawToken = this.token.replace('Bearer ', '');\n\n        // 创建聊天WebSocket连接\n        var chatSocket = new ReconnectingWebSocket(\"\".concat(WS_BASE_URL, \"/chat/\").concat(userId, \"?token=\").concat(encodeURIComponent(rawToken)), [], WS_CONFIG);\n\n        // 设置事件处理器\n        this._setupChatSocketHandlers(chatSocket, userId);\n\n        // 保存连接\n        this.chatSockets[userId] = chatSocket;\n      } catch (error) {\n        console.error(\"\\u521B\\u5EFA\\u4E0E\\u7528\\u6237\".concat(userId, \"\\u7684\\u804A\\u5929WebSocket\\u8FDE\\u63A5\\u5931\\u8D25:\"), error);\n      }\n    }\n\n    /**\n     * 设置聊天WebSocket的事件处理器\n     * @param {ReconnectingWebSocket} socket - WebSocket实例\n     * @param {number} userId - 对方用户ID\n     * @private\n     */\n  }, {\n    key: \"_setupChatSocketHandlers\",\n    value: function _setupChatSocketHandlers(socket, userId) {\n      var _this3 = this;\n      // 连接打开时的处理\n      socket.onopen = function () {\n        console.log(\"\\u4E0E\\u7528\\u6237\".concat(userId, \"\\u7684\\u804A\\u5929WebSocket\\u8FDE\\u63A5\\u5DF2\\u5EFA\\u7ACB\"));\n      };\n\n      // 接收消息的处理\n      socket.onmessage = function (event) {\n        try {\n          var data = JSON.parse(event.data);\n          _this3._handleChatMessage(data, userId);\n        } catch (error) {\n          console.error('解析聊天消息失败:', error);\n        }\n      };\n\n      // 连接关闭时的处理\n      socket.onclose = function (event) {\n        console.log(\"\\u4E0E\\u7528\\u6237\".concat(userId, \"\\u7684\\u804A\\u5929WebSocket\\u8FDE\\u63A5\\u5DF2\\u5173\\u95ED\"));\n        delete _this3.chatSockets[userId];\n\n        // 处理特定的关闭代码\n        _this3._handleChatSocketClose(event, userId);\n      };\n\n      // 连接错误时的处理\n      socket.onerror = function (error) {\n        console.error(\"\\u4E0E\\u7528\\u6237\".concat(userId, \"\\u7684\\u804A\\u5929WebSocket\\u8FDE\\u63A5\\u9519\\u8BEF:\"), error);\n      };\n    }\n\n    /**\n     * 处理聊天消息\n     * @param {Object} data - 消息数据\n     * @param {number} userId - 对方用户ID\n     * @private\n     */\n  }, {\n    key: \"_handleChatMessage\",\n    value: function _handleChatMessage(data, userId) {\n      switch (data.type) {\n        case 'connection_established':\n          console.log(data.message);\n          break;\n        case 'chat_message':\n          // 处理聊天消息，添加去重逻辑\n          if (!store.getters['chat/hasMessage'](data.id)) {\n            var _store$state$user;\n            var currentUserId = (_store$state$user = store.state.user) === null || _store$state$user === void 0 || (_store$state$user = _store$state$user.currentUser) === null || _store$state$user === void 0 ? void 0 : _store$state$user.id;\n            store.commit('chat/addMessage', {\n              userId: data.sender_id === currentUserId ? data.receiver_id : data.sender_id,\n              message: {\n                id: data.id,\n                senderId: data.sender_id,\n                receiverId: data.receiver_id,\n                content: data.content,\n                timestamp: data.timestamp,\n                isRead: data.is_read\n              }\n            });\n          }\n          break;\n        case 'history_messages':\n          // 处理历史消息\n          store.commit('chat/setMessages', {\n            userId: userId,\n            messages: data.messages.map(function (msg) {\n              return {\n                id: msg.id,\n                senderId: msg.sender_id,\n                receiverId: msg.receiver_id,\n                content: msg.content,\n                timestamp: msg.timestamp,\n                isRead: msg.is_read\n              };\n            }),\n            hasMore: data.has_more,\n            page: data.page\n          });\n          break;\n        default:\n          console.log('未知的聊天消息类型:', data.type);\n      }\n    }\n\n    /**\n     * 处理聊天WebSocket关闭事件\n     * @param {CloseEvent} event - 关闭事件\n     * @param {number} userId - 对方用户ID\n     * @private\n     */\n  }, {\n    key: \"_handleChatSocketClose\",\n    value: function _handleChatSocketClose(event, userId) {\n      switch (event.code) {\n        case 4001:\n          console.error('WebSocket连接失败：未提供token');\n          break;\n        case 4002:\n          console.error('WebSocket连接失败：用户不存在');\n          break;\n        case 4003:\n          console.error('WebSocket连接失败：token无效');\n          // 可能需要触发重新登录\n          store.dispatch('auth/logout');\n          break;\n        default:\n          if (event.code !== 1000) {\n            // 1000是正常关闭\n            console.error(\"WebSocket\\u8FDE\\u63A5\\u5F02\\u5E38\\u5173\\u95ED\\uFF0C\\u4EE3\\u7801\\uFF1A\".concat(event.code));\n          }\n      }\n    }\n\n    /**\n     * 断开与用户的聊天连接\n     * @param {number} userId - 用户ID\n     */\n  }, {\n    key: \"disconnectChat\",\n    value: function disconnectChat(userId) {\n      if (this.chatSockets[userId]) {\n        this.chatSockets[userId].close();\n        delete this.chatSockets[userId];\n      }\n    }\n\n    /**\n     * 发送聊天消息\n     * @param {number} userId - 接收者ID\n     * @param {string} content - 消息内容\n     */\n  }, {\n    key: \"sendChatMessage\",\n    value: function sendChatMessage(userId, content) {\n      if (!content.trim()) return;\n      if (!this.chatSockets[userId]) {\n        this.connectChat(userId);\n      }\n\n      // 确保连接已建立\n      var socket = this.chatSockets[userId];\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        socket.send(JSON.stringify({\n          type: 'chat_message',\n          content: content\n        }));\n      } else {\n        console.error(\"\\u4E0E\\u7528\\u6237\".concat(userId, \"\\u7684WebSocket\\u8FDE\\u63A5\\u672A\\u5C31\\u7EEA\\uFF0C\\u65E0\\u6CD5\\u53D1\\u9001\\u6D88\\u606F\"));\n        // 可以在这里添加消息队列，等连接建立后再发送\n      }\n    }\n\n    /**\n     * 加载历史消息\n     * @param {number} userId - 用户ID\n     * @param {number} page - 页码\n     * @param {number} pageSize - 每页大小\n     */\n  }, {\n    key: \"loadChatHistory\",\n    value: function loadChatHistory(userId) {\n      var _this4 = this;\n      var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var pageSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;\n      if (!this.chatSockets[userId]) {\n        this.connectChat(userId);\n        // 给连接一点时间建立\n        setTimeout(function () {\n          return _this4._sendLoadHistoryRequest(userId, page, pageSize);\n        }, 500);\n      } else {\n        this._sendLoadHistoryRequest(userId, page, pageSize);\n      }\n    }\n\n    /**\n     * 发送加载历史消息请求\n     * @param {number} userId - 用户ID\n     * @param {number} page - 页码\n     * @param {number} pageSize - 每页大小\n     * @private\n     */\n  }, {\n    key: \"_sendLoadHistoryRequest\",\n    value: function _sendLoadHistoryRequest(userId, page, pageSize) {\n      var socket = this.chatSockets[userId];\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        socket.send(JSON.stringify({\n          type: 'load_history',\n          page: page,\n          page_size: pageSize\n        }));\n      } else {\n        console.error(\"\\u4E0E\\u7528\\u6237\".concat(userId, \"\\u7684WebSocket\\u8FDE\\u63A5\\u672A\\u5C31\\u7EEA\\uFF0C\\u65E0\\u6CD5\\u52A0\\u8F7D\\u5386\\u53F2\\u6D88\\u606F\"));\n      }\n    }\n\n    /**\n     * 标记通知为已读\n     * @param {number} notificationId - 通知ID\n     */\n  }, {\n    key: \"markNotificationRead\",\n    value: function markNotificationRead(notificationId) {\n      if (this.notificationSocket && this.notificationSocket.readyState === WebSocket.OPEN) {\n        this.notificationSocket.send(JSON.stringify({\n          type: 'mark_read',\n          id: notificationId\n        }));\n      }\n    }\n\n    /**\n     * 标记所有通知为已读\n     */\n  }, {\n    key: \"markAllNotificationsRead\",\n    value: function markAllNotificationsRead() {\n      if (this.notificationSocket && this.notificationSocket.readyState === WebSocket.OPEN) {\n        this.notificationSocket.send(JSON.stringify({\n          type: 'mark_all_read'\n        }));\n      }\n    }\n\n    /**\n     * 关闭所有WebSocket连接\n     */\n  }, {\n    key: \"closeAll\",\n    value: function closeAll() {\n      if (this.notificationSocket) {\n        this.notificationSocket.close();\n        this.notificationSocket = null;\n      }\n      Object.values(this.chatSockets).forEach(function (socket) {\n        socket.close();\n      });\n      this.chatSockets = {};\n      this.token = null;\n    }\n  }]);\n}(); // 创建单例\nvar wsManager = new WebSocketManager();\nexport default wsManager;","map":{"version":3,"names":["ReconnectingWebSocket","store","ElMessage","WS_BASE_URL","process","env","NODE_ENV","WS_CONFIG","connectionTimeout","maxRetries","maxReconnectionDelay","minReconnectionDelay","debug","wsOptions","origin","window","location","WebSocketManager","_classCallCheck","notificationSocket","chatSockets","token","connectionAttempts","maxConnectionAttempts","_createClass","key","value","init","localStorage","getItem","console","log","_checkNotificationApiAvailability","_this","fetch","concat","protocol","host","headers","then","response","status","connectNotification","error","setTimeout","close","webSocketEnabled","rawToken","replace","encodeURIComponent","_setupNotificationSocketHandlers","_this2","onopen","onmessage","event","data","JSON","parse","_handleNotificationMessage","onclose","onerror","type","message","commit","count","title","duration","connectChat","userId","chatSocket","_setupChatSocketHandlers","socket","_this3","_handleChatMessage","_handleChatSocketClose","getters","id","_store$state$user","currentUserId","state","user","currentUser","sender_id","receiver_id","senderId","receiverId","content","timestamp","isRead","is_read","messages","map","msg","hasMore","has_more","page","code","dispatch","disconnectChat","sendChatMessage","trim","readyState","WebSocket","OPEN","send","stringify","loadChatHistory","_this4","arguments","length","undefined","pageSize","_sendLoadHistoryRequest","page_size","markNotificationRead","notificationId","markAllNotificationsRead","closeAll","Object","values","forEach","wsManager"],"sources":["H:/ForumServers/ForumFrontend/src/utils/websocket.js"],"sourcesContent":["import ReconnectingWebSocket from 'reconnecting-websocket';\nimport store from '@/store';\nimport { ElMessage } from 'element-plus';\n\n// WebSocket基础URL - 根据环境配置\nconst WS_BASE_URL = process.env.NODE_ENV === 'production' \n  ? 'wss://yourserver.com/ws' \n  : 'ws://localhost:8001/ws';\n\n// WebSocket配置\nconst WS_CONFIG = {\n  connectionTimeout: 5000,\n  maxRetries: 10,\n  maxReconnectionDelay: 5000,\n  minReconnectionDelay: 1000,\n  debug: false,\n  wsOptions: {\n    origin: window.location.origin\n  }\n};\n\n/**\n * WebSocket管理类\n * 负责管理通知和聊天的WebSocket连接\n */\nclass WebSocketManager {\n  constructor() {\n    this.notificationSocket = null;\n    this.chatSockets = {};\n    this.token = null;\n    this.connectionAttempts = 0;\n    this.maxConnectionAttempts = 5;\n  }\n\n  /**\n   * 初始化WebSocket连接\n   * @param {string} token - JWT令牌\n   */\n  init(token) {\n    // 重置连接尝试次数\n    this.connectionAttempts = 0;\n    \n    // 保存或获取token\n    this.token = token || localStorage.getItem('token');\n    if (!this.token) {\n      console.log('无法获取令牌，不建立WebSocket连接');\n      return;\n    }\n    \n    // 检查通知API是否可用\n    this._checkNotificationApiAvailability();\n  }\n\n  /**\n   * 检查通知API是否可用\n   * @private\n   */\n  _checkNotificationApiAvailability() {\n    fetch(`${window.location.protocol}//${window.location.host}/api/v1/notifications/`, {\n      headers: {\n        'Authorization': `Bearer ${this.token}`\n      }\n    })\n      .then(response => {\n        if (response.status !== 404) {\n          this.connectNotification(this.token);\n        } else {\n          console.log('通知接口不可用，不建立WebSocket连接');\n        }\n      })\n      .catch(error => {\n        console.error('检查通知接口可用性失败:', error);\n        \n        // 如果是网络问题，稍后重试\n        if (this.connectionAttempts < this.maxConnectionAttempts) {\n          this.connectionAttempts++;\n          setTimeout(() => this._checkNotificationApiAvailability(), 3000);\n        }\n      });\n  }\n\n  /**\n   * 连接到通知WebSocket\n   * @param {string} token - JWT令牌\n   */\n  connectNotification(token) {\n    // 关闭现有连接\n    if (this.notificationSocket) {\n      this.notificationSocket.close();\n      this.notificationSocket = null;\n    }\n\n    // 检查WebSocket功能是否已被禁用\n    if (window.webSocketEnabled === false) {\n      console.log('WebSocket功能已被禁用，不再尝试连接');\n      return;\n    }\n\n    try {\n      // 从Bearer token中提取实际的token\n      const rawToken = token.replace('Bearer ', '');\n      \n      // 创建通知WebSocket连接\n      this.notificationSocket = new ReconnectingWebSocket(\n        `${WS_BASE_URL}/notifications/?token=${encodeURIComponent(rawToken)}`,\n        [],\n        WS_CONFIG\n      );\n\n      // 设置事件处理器\n      this._setupNotificationSocketHandlers();\n    } catch (error) {\n      console.error('创建通知WebSocket连接失败:', error);\n    }\n  }\n  \n  /**\n   * 设置通知WebSocket的事件处理器\n   * @private\n   */\n  _setupNotificationSocketHandlers() {\n    // 连接打开时的处理\n    this.notificationSocket.onopen = () => {\n      console.log('通知WebSocket连接已建立');\n      // 重置连接尝试次数\n      this.connectionAttempts = 0;\n    };\n\n    // 接收消息的处理\n    this.notificationSocket.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        this._handleNotificationMessage(data);\n      } catch (error) {\n        console.error('解析通知消息失败:', error);\n      }\n    };\n\n    // 连接关闭时的处理\n    this.notificationSocket.onclose = () => {\n      console.log('通知WebSocket连接已关闭');\n    };\n\n    // 连接错误时的处理\n    this.notificationSocket.onerror = (error) => {\n      console.error('通知WebSocket连接错误:', error);\n      \n      // 连接错误次数过多时，禁用WebSocket功能\n      if (++this.connectionAttempts >= this.maxConnectionAttempts) {\n        console.log(`连接尝试次数(${this.connectionAttempts})达到上限，禁用WebSocket功能`);\n        window.webSocketEnabled = false;\n      }\n    };\n  }\n  \n  /**\n   * 处理通知消息\n   * @param {Object} data - 消息数据\n   * @private\n   */\n  _handleNotificationMessage(data) {\n    switch (data.type) {\n      case 'connection_established':\n        console.log(data.message);\n        break;\n      \n      case 'unread_count':\n        // 更新未读通知数量\n        store.commit('notifications/setUnreadCount', data.count);\n        break;\n      \n      case 'notification':\n        // 处理新通知\n        store.commit('notifications/addNotification', data);\n        store.commit('notifications/incrementUnreadCount');\n        \n        // 显示通知提示\n        ElMessage({\n          message: data.title,\n          type: 'info',\n          duration: 3000\n        });\n        break;\n      \n      case 'mark_read_response':\n      case 'mark_all_read_response':\n        // 标记通知已读的响应处理\n        break;\n      \n      default:\n        console.log('未知的通知类型:', data.type);\n    }\n  }\n\n  /**\n   * 连接到聊天WebSocket\n   * @param {number} userId - 对方用户ID\n   */\n  connectChat(userId) {\n    if (!this.token) {\n      console.error('未登录，无法建立聊天连接');\n      return;\n    }\n\n    // 如果已存在与该用户的连接，则返回\n    if (this.chatSockets[userId]) {\n      return;\n    }\n\n    try {\n      // 从Bearer token中提取实际的token\n      const rawToken = this.token.replace('Bearer ', '');\n\n      // 创建聊天WebSocket连接\n      const chatSocket = new ReconnectingWebSocket(\n        `${WS_BASE_URL}/chat/${userId}?token=${encodeURIComponent(rawToken)}`,\n        [],\n        WS_CONFIG\n      );\n\n      // 设置事件处理器\n      this._setupChatSocketHandlers(chatSocket, userId);\n      \n      // 保存连接\n      this.chatSockets[userId] = chatSocket;\n    } catch (error) {\n      console.error(`创建与用户${userId}的聊天WebSocket连接失败:`, error);\n    }\n  }\n  \n  /**\n   * 设置聊天WebSocket的事件处理器\n   * @param {ReconnectingWebSocket} socket - WebSocket实例\n   * @param {number} userId - 对方用户ID\n   * @private\n   */\n  _setupChatSocketHandlers(socket, userId) {\n    // 连接打开时的处理\n    socket.onopen = () => {\n      console.log(`与用户${userId}的聊天WebSocket连接已建立`);\n    };\n\n    // 接收消息的处理\n    socket.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        this._handleChatMessage(data, userId);\n      } catch (error) {\n        console.error('解析聊天消息失败:', error);\n      }\n    };\n\n    // 连接关闭时的处理\n    socket.onclose = (event) => {\n      console.log(`与用户${userId}的聊天WebSocket连接已关闭`);\n      delete this.chatSockets[userId];\n\n      // 处理特定的关闭代码\n      this._handleChatSocketClose(event, userId);\n    };\n\n    // 连接错误时的处理\n    socket.onerror = (error) => {\n      console.error(`与用户${userId}的聊天WebSocket连接错误:`, error);\n    };\n  }\n  \n  /**\n   * 处理聊天消息\n   * @param {Object} data - 消息数据\n   * @param {number} userId - 对方用户ID\n   * @private\n   */\n  _handleChatMessage(data, userId) {\n    switch (data.type) {\n      case 'connection_established':\n        console.log(data.message);\n        break;\n      \n      case 'chat_message':\n        // 处理聊天消息，添加去重逻辑\n        if (!store.getters['chat/hasMessage'](data.id)) {\n          const currentUserId = store.state.user?.currentUser?.id;\n          store.commit('chat/addMessage', {\n            userId: data.sender_id === currentUserId ? data.receiver_id : data.sender_id,\n            message: {\n              id: data.id,\n              senderId: data.sender_id,\n              receiverId: data.receiver_id,\n              content: data.content,\n              timestamp: data.timestamp,\n              isRead: data.is_read\n            }\n          });\n        }\n        break;\n      \n      case 'history_messages':\n        // 处理历史消息\n        store.commit('chat/setMessages', {\n          userId: userId,\n          messages: data.messages.map(msg => ({\n            id: msg.id,\n            senderId: msg.sender_id,\n            receiverId: msg.receiver_id,\n            content: msg.content,\n            timestamp: msg.timestamp,\n            isRead: msg.is_read\n          })),\n          hasMore: data.has_more,\n          page: data.page\n        });\n        break;\n      \n      default:\n        console.log('未知的聊天消息类型:', data.type);\n    }\n  }\n  \n  /**\n   * 处理聊天WebSocket关闭事件\n   * @param {CloseEvent} event - 关闭事件\n   * @param {number} userId - 对方用户ID\n   * @private\n   */\n  _handleChatSocketClose(event, userId) {\n    switch (event.code) {\n      case 4001:\n        console.error('WebSocket连接失败：未提供token');\n        break;\n      case 4002:\n        console.error('WebSocket连接失败：用户不存在');\n        break;\n      case 4003:\n        console.error('WebSocket连接失败：token无效');\n        // 可能需要触发重新登录\n        store.dispatch('auth/logout');\n        break;\n      default:\n        if (event.code !== 1000) {  // 1000是正常关闭\n          console.error(`WebSocket连接异常关闭，代码：${event.code}`);\n        }\n    }\n  }\n\n  /**\n   * 断开与用户的聊天连接\n   * @param {number} userId - 用户ID\n   */\n  disconnectChat(userId) {\n    if (this.chatSockets[userId]) {\n      this.chatSockets[userId].close();\n      delete this.chatSockets[userId];\n    }\n  }\n\n  /**\n   * 发送聊天消息\n   * @param {number} userId - 接收者ID\n   * @param {string} content - 消息内容\n   */\n  sendChatMessage(userId, content) {\n    if (!content.trim()) return;\n    \n    if (!this.chatSockets[userId]) {\n      this.connectChat(userId);\n    }\n\n    // 确保连接已建立\n    const socket = this.chatSockets[userId];\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        type: 'chat_message',\n        content: content\n      }));\n    } else {\n      console.error(`与用户${userId}的WebSocket连接未就绪，无法发送消息`);\n      // 可以在这里添加消息队列，等连接建立后再发送\n    }\n  }\n\n  /**\n   * 加载历史消息\n   * @param {number} userId - 用户ID\n   * @param {number} page - 页码\n   * @param {number} pageSize - 每页大小\n   */\n  loadChatHistory(userId, page = 1, pageSize = 20) {\n    if (!this.chatSockets[userId]) {\n      this.connectChat(userId);\n      // 给连接一点时间建立\n      setTimeout(() => this._sendLoadHistoryRequest(userId, page, pageSize), 500);\n    } else {\n      this._sendLoadHistoryRequest(userId, page, pageSize);\n    }\n  }\n  \n  /**\n   * 发送加载历史消息请求\n   * @param {number} userId - 用户ID\n   * @param {number} page - 页码\n   * @param {number} pageSize - 每页大小\n   * @private\n   */\n  _sendLoadHistoryRequest(userId, page, pageSize) {\n    const socket = this.chatSockets[userId];\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        type: 'load_history',\n        page: page,\n        page_size: pageSize\n      }));\n    } else {\n      console.error(`与用户${userId}的WebSocket连接未就绪，无法加载历史消息`);\n    }\n  }\n\n  /**\n   * 标记通知为已读\n   * @param {number} notificationId - 通知ID\n   */\n  markNotificationRead(notificationId) {\n    if (this.notificationSocket && this.notificationSocket.readyState === WebSocket.OPEN) {\n      this.notificationSocket.send(JSON.stringify({\n        type: 'mark_read',\n        id: notificationId\n      }));\n    }\n  }\n\n  /**\n   * 标记所有通知为已读\n   */\n  markAllNotificationsRead() {\n    if (this.notificationSocket && this.notificationSocket.readyState === WebSocket.OPEN) {\n      this.notificationSocket.send(JSON.stringify({\n        type: 'mark_all_read'\n      }));\n    }\n  }\n\n  /**\n   * 关闭所有WebSocket连接\n   */\n  closeAll() {\n    if (this.notificationSocket) {\n      this.notificationSocket.close();\n      this.notificationSocket = null;\n    }\n\n    Object.values(this.chatSockets).forEach(socket => {\n      socket.close();\n    });\n    this.chatSockets = {};\n    this.token = null;\n  }\n}\n\n// 创建单例\nconst wsManager = new WebSocketManager();\n\nexport default wsManager; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}