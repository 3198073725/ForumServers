{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\")[\"default\"];\nvar _objectSpread = require(\"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/objectSpread2.js\")[\"default\"];\nvar _asyncToGenerator = require(\"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\")[\"default\"];\nvar _slicedToArray = require(\"H:/ForumServers/ForumFrontend/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\nrequire(\"core-js/modules/es.array.includes.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.object.define-property.js\");\nrequire(\"core-js/modules/web.timers.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vue = require('vue');\nvar lodashUnified = require('lodash-unified');\nvar utils = require('./utils.js');\nvar tokens = require('./tokens.js');\nvar pluginVue_exportHelper = require('../../../_virtual/plugin-vue_export-helper.js');\nvar index = require('../../../hooks/use-escape-keydown/index.js');\nvar aria = require('../../../constants/aria.js');\nvar shared = require('@vue/shared');\nvar _sfc_main = vue.defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object,\n    focusStartEl: {\n      type: [Object, String],\n      \"default\": \"first\"\n    }\n  },\n  emits: [tokens.ON_TRAP_FOCUS_EVT, tokens.ON_RELEASE_FOCUS_EVT, \"focusin\", \"focusout\", \"focusout-prevented\", \"release-requested\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n    var forwardRef = vue.ref();\n    var lastFocusBeforeTrapped;\n    var lastFocusAfterTrapped;\n    var _utils$useFocusReason = utils.useFocusReason(),\n      focusReason = _utils$useFocusReason.focusReason;\n    index.useEscapeKeydown(function (event) {\n      if (props.trapped && !focusLayer.paused) {\n        emit(\"release-requested\", event);\n      }\n    });\n    var focusLayer = {\n      paused: false,\n      pause: function pause() {\n        this.paused = true;\n      },\n      resume: function resume() {\n        this.paused = false;\n      }\n    };\n    var onKeydown = function onKeydown(e) {\n      if (!props.loop && !props.trapped) return;\n      if (focusLayer.paused) return;\n      var code = e.code,\n        altKey = e.altKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        currentTarget = e.currentTarget,\n        shiftKey = e.shiftKey;\n      var loop = props.loop;\n      var isTabbing = code === aria.EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      var currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        var container = currentTarget;\n        var _utils$getEdges = utils.getEdges(container),\n          _utils$getEdges2 = _slicedToArray(_utils$getEdges, 2),\n          first = _utils$getEdges2[0],\n          last = _utils$getEdges2[1];\n        var isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            var focusoutPreventedEvent = utils.createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            var _focusoutPreventedEvent = utils.createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", _focusoutPreventedEvent);\n            if (!_focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop) utils.tryFocus(first, true);\n            }\n          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {\n            var _focusoutPreventedEvent2 = utils.createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", _focusoutPreventedEvent2);\n            if (!_focusoutPreventedEvent2.defaultPrevented) {\n              e.preventDefault();\n              if (loop) utils.tryFocus(last, true);\n            }\n          }\n        }\n      }\n    };\n    vue.provide(tokens.FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown: onKeydown\n    });\n    vue.watch(function () {\n      return props.focusTrapEl;\n    }, function (focusTrapEl) {\n      if (focusTrapEl) {\n        forwardRef.value = focusTrapEl;\n      }\n    }, {\n      immediate: true\n    });\n    vue.watch([forwardRef], function (_ref2, _ref3) {\n      var _ref4 = _slicedToArray(_ref2, 1),\n        forwardRef2 = _ref4[0];\n      var _ref5 = _slicedToArray(_ref3, 1),\n        oldForwardRef = _ref5[0];\n      if (forwardRef2) {\n        forwardRef2.addEventListener(\"keydown\", onKeydown);\n        forwardRef2.addEventListener(\"focusin\", onFocusIn);\n        forwardRef2.addEventListener(\"focusout\", onFocusOut);\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener(\"keydown\", onKeydown);\n        oldForwardRef.removeEventListener(\"focusin\", onFocusIn);\n        oldForwardRef.removeEventListener(\"focusout\", onFocusOut);\n      }\n    });\n    var trapOnFocus = function trapOnFocus(e) {\n      emit(tokens.ON_TRAP_FOCUS_EVT, e);\n    };\n    var releaseOnFocus = function releaseOnFocus(e) {\n      return emit(tokens.ON_RELEASE_FOCUS_EVT, e);\n    };\n    var onFocusIn = function onFocusIn(e) {\n      var trapContainer = vue.unref(forwardRef);\n      if (!trapContainer) return;\n      var target = e.target;\n      var relatedTarget = e.relatedTarget;\n      var isFocusedInTrap = target && trapContainer.contains(target);\n      if (!props.trapped) {\n        var isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget;\n        }\n      }\n      if (isFocusedInTrap) emit(\"focusin\", e);\n      if (focusLayer.paused) return;\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target;\n        } else {\n          utils.tryFocus(lastFocusAfterTrapped, true);\n        }\n      }\n    };\n    var onFocusOut = function onFocusOut(e) {\n      var trapContainer = vue.unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      if (props.trapped) {\n        var relatedTarget = e.relatedTarget;\n        if (!lodashUnified.isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          setTimeout(function () {\n            if (!focusLayer.paused && props.trapped) {\n              var focusoutPreventedEvent = utils.createFocusOutPreventedEvent({\n                focusReason: focusReason.value\n              });\n              emit(\"focusout-prevented\", focusoutPreventedEvent);\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                utils.tryFocus(lastFocusAfterTrapped, true);\n              }\n            }\n          }, 0);\n        }\n      } else {\n        var target = e.target;\n        var isFocusedInTrap = target && trapContainer.contains(target);\n        if (!isFocusedInTrap) emit(\"focusout\", e);\n      }\n    };\n    function startTrap() {\n      return _startTrap.apply(this, arguments);\n    }\n    function _startTrap() {\n      _startTrap = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var trapContainer, prevFocusedElement, isPrevFocusContained, focusEvent;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return vue.nextTick();\n            case 2:\n              trapContainer = vue.unref(forwardRef);\n              if (trapContainer) {\n                utils.focusableStack.push(focusLayer);\n                prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;\n                lastFocusBeforeTrapped = prevFocusedElement;\n                isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n                if (!isPrevFocusContained) {\n                  focusEvent = new Event(tokens.FOCUS_AFTER_TRAPPED, tokens.FOCUS_AFTER_TRAPPED_OPTS);\n                  trapContainer.addEventListener(tokens.FOCUS_AFTER_TRAPPED, trapOnFocus);\n                  trapContainer.dispatchEvent(focusEvent);\n                  if (!focusEvent.defaultPrevented) {\n                    vue.nextTick(function () {\n                      var focusStartEl = props.focusStartEl;\n                      if (!shared.isString(focusStartEl)) {\n                        utils.tryFocus(focusStartEl);\n                        if (document.activeElement !== focusStartEl) {\n                          focusStartEl = \"first\";\n                        }\n                      }\n                      if (focusStartEl === \"first\") {\n                        utils.focusFirstDescendant(utils.obtainAllFocusableElements(trapContainer), true);\n                      }\n                      if (document.activeElement === prevFocusedElement || focusStartEl === \"container\") {\n                        utils.tryFocus(trapContainer);\n                      }\n                    });\n                  }\n                }\n              }\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return _startTrap.apply(this, arguments);\n    }\n    function stopTrap() {\n      var trapContainer = vue.unref(forwardRef);\n      if (trapContainer) {\n        trapContainer.removeEventListener(tokens.FOCUS_AFTER_TRAPPED, trapOnFocus);\n        var releasedEvent = new CustomEvent(tokens.FOCUS_AFTER_RELEASED, _objectSpread(_objectSpread({}, tokens.FOCUS_AFTER_TRAPPED_OPTS), {}, {\n          detail: {\n            focusReason: focusReason.value\n          }\n        }));\n        trapContainer.addEventListener(tokens.FOCUS_AFTER_RELEASED, releaseOnFocus);\n        trapContainer.dispatchEvent(releasedEvent);\n        if (!releasedEvent.defaultPrevented && (focusReason.value == \"keyboard\" || !utils.isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {\n          utils.tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);\n        }\n        trapContainer.removeEventListener(tokens.FOCUS_AFTER_RELEASED, releaseOnFocus);\n        utils.focusableStack.remove(focusLayer);\n      }\n    }\n    vue.onMounted(function () {\n      if (props.trapped) {\n        startTrap();\n      }\n      vue.watch(function () {\n        return props.trapped;\n      }, function (trapped) {\n        if (trapped) {\n          startTrap();\n        } else {\n          stopTrap();\n        }\n      });\n    });\n    vue.onBeforeUnmount(function () {\n      if (props.trapped) {\n        stopTrap();\n      }\n      if (forwardRef.value) {\n        forwardRef.value.removeEventListener(\"keydown\", onKeydown);\n        forwardRef.value.removeEventListener(\"focusin\", onFocusIn);\n        forwardRef.value.removeEventListener(\"focusout\", onFocusOut);\n        forwardRef.value = void 0;\n      }\n    });\n    return {\n      onKeydown: onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return vue.renderSlot(_ctx.$slots, \"default\", {\n    handleKeydown: _ctx.onKeydown\n  });\n}\nvar ElFocusTrap = /* @__PURE__ */pluginVue_exportHelper[\"default\"](_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"focus-trap.vue\"]]);\nexports[\"default\"] = ElFocusTrap;","map":{"version":3,"names":["_sfc_main","vue","defineComponent","name","inheritAttrs","props","loop","Boolean","trapped","focusTrapEl","Object","focusStartEl","type","String","emits","tokens","ON_TRAP_FOCUS_EVT","ON_RELEASE_FOCUS_EVT","setup","_ref","emit","forwardRef","ref","lastFocusBeforeTrapped","lastFocusAfterTrapped","_utils$useFocusReason","utils","useFocusReason","focusReason","index","useEscapeKeydown","event","focusLayer","paused","pause","resume","onKeydown","e","code","altKey","ctrlKey","metaKey","currentTarget","shiftKey","isTabbing","aria","EVENT_CODE","tab","currentFocusingEl","document","activeElement","container","_utils$getEdges","getEdges","_utils$getEdges2","_slicedToArray","first","last","isTabbable","focusoutPreventedEvent","createFocusOutPreventedEvent","value","defaultPrevented","preventDefault","tryFocus","includes","provide","FOCUS_TRAP_INJECTION_KEY","focusTrapRef","watch","immediate","_ref2","_ref3","_ref4","forwardRef2","_ref5","oldForwardRef","addEventListener","onFocusIn","onFocusOut","removeEventListener","trapOnFocus","releaseOnFocus","trapContainer","unref","target","relatedTarget","isFocusedInTrap","contains","isPrevFocusedInTrap","lodashUnified","isNil","setTimeout","startTrap","_startTrap","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","prevFocusedElement","isPrevFocusContained","focusEvent","wrap","_callee$","_context","prev","next","nextTick","focusableStack","push","Event","FOCUS_AFTER_TRAPPED","FOCUS_AFTER_TRAPPED_OPTS","dispatchEvent","shared","isString","focusFirstDescendant","obtainAllFocusableElements","stop","stopTrap","releasedEvent","CustomEvent","FOCUS_AFTER_RELEASED","_objectSpread","detail","isFocusCausedByUserEvent","body","remove","onMounted","onBeforeUnmount","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","renderSlot","$slots","handleKeydown","ElFocusTrap","pluginVue_exportHelper"],"sources":["../../../../../../packages/components/focus-trap/src/focus-trap.vue"],"sourcesContent":["<template>\n  <slot :handle-keydown=\"onKeydown\" />\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { isNil } from 'lodash-unified'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useEscapeKeydown } from '@element-plus/hooks'\nimport { isString } from '@element-plus/utils'\nimport {\n  createFocusOutPreventedEvent,\n  focusFirstDescendant,\n  focusableStack,\n  getEdges,\n  isFocusCausedByUserEvent,\n  obtainAllFocusableElements,\n  tryFocus,\n  useFocusReason,\n} from './utils'\nimport {\n  FOCUS_AFTER_RELEASED,\n  FOCUS_AFTER_TRAPPED,\n  FOCUS_AFTER_TRAPPED_OPTS,\n  FOCUS_TRAP_INJECTION_KEY,\n  ON_RELEASE_FOCUS_EVT,\n  ON_TRAP_FOCUS_EVT,\n} from './tokens'\n\nimport type { PropType } from 'vue'\nimport type { FocusLayer } from './utils'\n\nexport default defineComponent({\n  name: 'ElFocusTrap',\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object as PropType<HTMLElement>,\n    focusStartEl: {\n      type: [Object, String] as PropType<'container' | 'first' | HTMLElement>,\n      default: 'first',\n    },\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    'focusin',\n    'focusout',\n    'focusout-prevented',\n    'release-requested',\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref<HTMLElement | undefined>()\n    let lastFocusBeforeTrapped: HTMLElement | null\n    let lastFocusAfterTrapped: HTMLElement | null\n\n    const { focusReason } = useFocusReason()\n\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit('release-requested', event)\n      }\n    })\n\n    const focusLayer: FocusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true\n      },\n      resume() {\n        this.paused = false\n      },\n    }\n\n    const onKeydown = (e: KeyboardEvent) => {\n      if (!props.loop && !props.trapped) return\n      if (focusLayer.paused) return\n\n      const { code, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e\n      const { loop } = props\n      const isTabbing =\n        code === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey\n\n      const currentFocusingEl = document.activeElement\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget as HTMLElement\n        const [first, last] = getEdges(container)\n        const isTabbable = first && last\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n              if (loop) tryFocus(first, true)\n            }\n          } else if (\n            shiftKey &&\n            [first, container].includes(currentFocusingEl as HTMLElement)\n          ) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n              if (loop) tryFocus(last, true)\n            }\n          }\n        }\n      }\n    }\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown,\n    })\n\n    watch(\n      () => props.focusTrapEl,\n      (focusTrapEl) => {\n        if (focusTrapEl) {\n          forwardRef.value = focusTrapEl\n        }\n      },\n      { immediate: true }\n    )\n\n    watch([forwardRef], ([forwardRef], [oldForwardRef]) => {\n      if (forwardRef) {\n        forwardRef.addEventListener('keydown', onKeydown)\n        forwardRef.addEventListener('focusin', onFocusIn)\n        forwardRef.addEventListener('focusout', onFocusOut)\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener('keydown', onKeydown)\n        oldForwardRef.removeEventListener('focusin', onFocusIn)\n        oldForwardRef.removeEventListener('focusout', onFocusOut)\n      }\n    })\n\n    const trapOnFocus = (e: Event) => {\n      emit(ON_TRAP_FOCUS_EVT, e)\n    }\n    const releaseOnFocus = (e: Event) => emit(ON_RELEASE_FOCUS_EVT, e)\n\n    const onFocusIn = (e: FocusEvent) => {\n      const trapContainer = unref(forwardRef)\n      if (!trapContainer) return\n\n      const target = e.target as HTMLElement | null\n      const relatedTarget = e.relatedTarget as HTMLElement | null\n      const isFocusedInTrap = target && trapContainer.contains(target)\n\n      if (!props.trapped) {\n        const isPrevFocusedInTrap =\n          relatedTarget && trapContainer.contains(relatedTarget)\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget\n        }\n      }\n\n      if (isFocusedInTrap) emit('focusin', e)\n\n      if (focusLayer.paused) return\n\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target\n        } else {\n          tryFocus(lastFocusAfterTrapped, true)\n        }\n      }\n    }\n\n    const onFocusOut = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n\n      if (props.trapped) {\n        const relatedTarget = (e as FocusEvent)\n          .relatedTarget as HTMLElement | null\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          // Give embedded focus layer time to pause this layer before reclaiming focus\n          // And only reclaim focus if it should currently be trapping\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              const focusoutPreventedEvent = createFocusOutPreventedEvent({\n                focusReason: focusReason.value,\n              })\n              emit('focusout-prevented', focusoutPreventedEvent)\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                tryFocus(lastFocusAfterTrapped, true)\n              }\n            }\n          }, 0)\n        }\n      } else {\n        const target = e.target as HTMLElement | null\n        const isFocusedInTrap = target && trapContainer.contains(target)\n        if (!isFocusedInTrap) emit('focusout', e)\n      }\n    }\n\n    async function startTrap() {\n      // Wait for forwardRef to resolve\n      await nextTick()\n      const trapContainer = unref(forwardRef)\n      if (trapContainer) {\n        focusableStack.push(focusLayer)\n        const prevFocusedElement = trapContainer.contains(\n          document.activeElement\n        )\n          ? lastFocusBeforeTrapped\n          : document.activeElement\n        lastFocusBeforeTrapped = prevFocusedElement as HTMLElement | null\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement)\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(\n            FOCUS_AFTER_TRAPPED,\n            FOCUS_AFTER_TRAPPED_OPTS\n          )\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n          trapContainer.dispatchEvent(focusEvent)\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl)\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = 'first'\n                }\n              }\n              if (focusStartEl === 'first') {\n                focusFirstDescendant(\n                  obtainAllFocusableElements(trapContainer),\n                  true\n                )\n              }\n              if (\n                document.activeElement === prevFocusedElement ||\n                focusStartEl === 'container'\n              ) {\n                tryFocus(trapContainer)\n              }\n            })\n          }\n        }\n      }\n    }\n\n    function stopTrap() {\n      const trapContainer = unref(forwardRef)\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n\n        const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {\n          ...FOCUS_AFTER_TRAPPED_OPTS,\n          detail: {\n            focusReason: focusReason.value,\n          },\n        })\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus)\n        trapContainer.dispatchEvent(releasedEvent)\n        if (\n          !releasedEvent.defaultPrevented &&\n          (focusReason.value == 'keyboard' ||\n            !isFocusCausedByUserEvent() ||\n            trapContainer.contains(document.activeElement))\n        ) {\n          tryFocus(lastFocusBeforeTrapped ?? document.body)\n        }\n\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus)\n        focusableStack.remove(focusLayer)\n      }\n    }\n\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap()\n      }\n\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            startTrap()\n          } else {\n            stopTrap()\n          }\n        }\n      )\n    })\n\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap()\n      }\n\n      if (forwardRef.value) {\n        forwardRef.value.removeEventListener('keydown', onKeydown)\n        forwardRef.value.removeEventListener('focusin', onFocusIn)\n        forwardRef.value.removeEventListener('focusout', onFocusOut)\n        forwardRef.value = undefined\n      }\n    })\n\n    return {\n      onKeydown,\n    }\n  },\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}